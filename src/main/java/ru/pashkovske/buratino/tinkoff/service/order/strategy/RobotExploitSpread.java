package ru.pashkovske.buratino.tinkoff.service.order.strategy;

import lombok.RequiredArgsConstructor;
import ru.pashkovske.buratino.tinkoff.service.instrument.selector.InstrumentSelector;
import ru.pashkovske.buratino.tinkoff.service.order.api.OrderApi;
import ru.pashkovske.buratino.tinkoff.service.order.model.OrderHolder;
import ru.pashkovske.buratino.tinkoff.service.order.model.OrderRequest;
import ru.pashkovske.buratino.tinkoff.service.assignment.Assignment;
import ru.pashkovske.buratino.tinkoff.service.assignment.ExploitRobotSpreadAssignment;
import ru.pashkovske.buratino.tinkoff.service.order.strategy.command.AssignmentCommand;
import ru.pashkovske.buratino.tinkoff.service.order.strategy.command.OtherRobotExploitWithSpread;
import ru.pashkovske.buratino.tinkoff.service.price.PriceUtils;
import ru.pashkovske.buratino.tinkoff.service.price.mapper.PriceMapper;
import ru.pashkovske.buratino.tinkoff.service.price.service.MarketPriceService;
import ru.tinkoff.piapi.contract.v1.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@RequiredArgsConstructor
public class RobotExploitSpread implements OrderStrategy {
    private final OrderApi orderApi;
    private final MarketPriceService marketPriceService;
    //private final AssignmentDao currentAssignments;
    private final InstrumentSelector instrumentSelector;
    private final Map<UUID, ExploitRobotSpreadAssignment> assignments = new HashMap<>();

    @Override
    public Assignment post(AssignmentCommand command) {
        OtherRobotExploitWithSpread commandCast = (OtherRobotExploitWithSpread) command;

        OrderDirection initialDirection = OrderDirection.ORDER_DIRECTION_BUY;
        OrderDirection initialInvertedDirection = OrderDirection.ORDER_DIRECTION_SELL;

        UUID assignmentId = UUID.randomUUID();
        ExploitRobotSpreadAssignment assignment = new ExploitRobotSpreadAssignment(
                assignmentId,
                new OrderHolder(),
                command,
                initialDirection,
                initialInvertedDirection
        );
        assignments.put(assignmentId, assignment);
        MoneyValue price = PriceMapper.map(
                commandCast.getMinAsk(),
                command.getInstrument()
        );
        OrderRequest orderRequest = new OrderRequest(
                command.getInstrument().getId().id(),
                price,
                assignment.getInvertedLastDirection(),
                1,
                OrderType.ORDER_TYPE_LIMIT,
                TimeInForceType.TIME_IN_FORCE_DAY
        );
        assignment.getOrder().setOrderRequest(orderRequest);
        assignment.getOrder().setOrderResponse(orderApi.post(orderRequest));

        return assignment;
    }

    @Override
    public List<Assignment> pull(List<OrderState> orders) {
        return List.of();
    }

    @Override
    public List<Assignment> pullAndSchedule(List<OrderState> orders) {
        throw new IllegalStateException("Не реализовано");
    }

    @Override
    public void scheduleRefresh(UUID assignmentId) {
        throw new IllegalStateException("Не реализовано");
    }

    @Override
    public Assignment refresh(UUID assignmentId) throws InterruptedException {
        ExploitRobotSpreadAssignment assignment = assignments.get(assignmentId);
        OtherRobotExploitWithSpread command = (OtherRobotExploitWithSpread)assignment.getCommand();
        List<OrderHolder> orders = assignment.getOrders();
        assert orders.size() == 1;
        OrderHolder order = orders.getFirst();
        String fakeOrderId = order.getOrderResponse().id();

        Quotation bestPrice = marketPriceService.getBestPrice(command.getInstrument(), assignment.getInvertedLastDirection());
        boolean isCorrect;
        if (assignment.getLastDirection().equals(OrderDirection.ORDER_DIRECTION_BUY)) {
            bestPrice = PriceUtils.plus(bestPrice, command.getInstrument().getMinPriceIncrement());
            bestPrice = PriceUtils.plus(bestPrice, command.getInstrument().getMinPriceIncrement());
            isCorrect = bestPrice.equals(command.getMinAsk());
            bestPrice = PriceUtils.minus(bestPrice, command.getInstrument().getMinPriceIncrement());
        }
        else if (assignment.getLastDirection().equals(OrderDirection.ORDER_DIRECTION_SELL)) {
            bestPrice = PriceUtils.minus(bestPrice, command.getInstrument().getMinPriceIncrement());
            bestPrice = PriceUtils.minus(bestPrice, command.getInstrument().getMinPriceIncrement());
            isCorrect = bestPrice.equals(command.getMaxBid());
            bestPrice = PriceUtils.plus(bestPrice, command.getInstrument().getMinPriceIncrement());
        }
        else {
            orderApi.cancelOrder(fakeOrderId);
            throw new IllegalStateException("Не определено последнее направление");
        }
        if (!isCorrect) {
            orderApi.cancelOrder(fakeOrderId);
            throw new IllegalStateException("Что-то не так с ценами");
        }
        MoneyValue price = PriceMapper.map(
                bestPrice,
                command.getInstrument()
        );

        OrderRequest orderRequest = new OrderRequest(
                command.getInstrument().getId().id(),
                price,
                assignment.getLastDirection(),
                command.getLotsQuantity(),
                OrderType.ORDER_TYPE_LIMIT,
                TimeInForceType.TIME_IN_FORCE_FILL_AND_KILL
        );
        orderApi.post(orderRequest);

        order.setOrderRequest(orderRequest);
        order.setOrderResponse(orderApi.post(orderRequest));
        orderApi.post(orderRequest);
        orderApi.cancelOrder(fakeOrderId);

        Thread.sleep(2000);

        if (assignment.getLastDirection().equals(OrderDirection.ORDER_DIRECTION_SELL)) {
            assignment.setLastDirection(OrderDirection.ORDER_DIRECTION_BUY);
            assignment.setInvertedLastDirection(OrderDirection.ORDER_DIRECTION_SELL);
            price = PriceMapper.map(
                    command.getMinAsk(),
                    command.getInstrument()
            );
            orderRequest = new OrderRequest(
                    command.getInstrument().getId().id(),
                    price,
                    assignment.getInvertedLastDirection(),
                    1,
                    OrderType.ORDER_TYPE_LIMIT,
                    TimeInForceType.TIME_IN_FORCE_DAY
            );
            assignment.getOrder().setOrderRequest(orderRequest);
            assignment.getOrder().setOrderResponse(orderApi.post(orderRequest));
        } else if (assignment.getLastDirection().equals(OrderDirection.ORDER_DIRECTION_BUY)) {
            assignment.setLastDirection(OrderDirection.ORDER_DIRECTION_SELL);
            assignment.setInvertedLastDirection(OrderDirection.ORDER_DIRECTION_BUY);
            price = PriceMapper.map(
                    command.getMaxBid(),
                    command.getInstrument()
            );
            orderRequest = new OrderRequest(
                    command.getInstrument().getId().id(),
                    price,
                    assignment.getInvertedLastDirection(),
                    1,
                    OrderType.ORDER_TYPE_LIMIT,
                    TimeInForceType.TIME_IN_FORCE_DAY
            );
            assignment.getOrder().setOrderRequest(orderRequest);
            assignment.getOrder().setOrderResponse(orderApi.post(orderRequest));
        }

        return assignment;
    }

    @Override
    public List<Assignment> refreshAll() throws InterruptedException {
        for (UUID assignmentId : assignments.keySet()) {
            refresh(assignmentId);
        }
        return assignments.values().stream().map(cmd -> (Assignment)cmd).toList();
    }

    @Override
    public void cancel(UUID assignmentId) {

    }

    @Override
    public List<Assignment> getAll() {
        return assignments.values().stream().map(assignment -> (Assignment)assignment).toList();
    }
}
